@Service
public class SalesService {

    @Autowired
    private JdbcTemplate jdbc;

    public Map<String, Object> getSalesData(String productId, String locationId, int duration) {

        // 1. Fetch start date from oh_table (global start date)
        LocalDate startDate = jdbc.queryForObject(
                "SELECT oh_start_date FROM oh_table WHERE product_id = ? AND location_id = ?",
                LocalDate.class,
                productId,
                locationId
        );

        // 2. Identify which table contains this product/location
        String tableUsed = null;
        Map<String, Object> row = null;

        // weekly
        try {
            row = jdbc.queryForMap(
                    "SELECT * FROM weekly_sales WHERE product_id = ? AND location_id = ?",
                    productId, locationId
            );
            tableUsed = "weekly";
        } catch (Exception ignored) {}

        // monthly
        if (row == null) {
            try {
                row = jdbc.queryForMap(
                        "SELECT * FROM monthly_sales WHERE product_id = ? AND location_id = ?",
                        productId, locationId
                );
                tableUsed = "monthly";
            } catch (Exception ignored) {}
        }

        // quarterly
        if (row == null) {
            row = jdbc.queryForMap(
                    "SELECT * FROM quarterly_sales WHERE product_id = ? AND location_id = ?",
                    productId, locationId
            );
            tableUsed = "quarterly";
        }


        // 3. START DATE FOR TERM1 (from the table)
        LocalDate termStart = ((java.sql.Date) row.get("date")).toLocalDate();

        // 4. Build map of daily sales
        Map<String, Double> dailySales = new LinkedHashMap<>();
        int currentTerm = 1;
        LocalDate runningDate = startDate; // final output always starts from oh_table start date
        int remainingDays = duration;

        while (remainingDays > 0) {

            String col = "term" + currentTerm;
            if (!row.containsKey(col)) break; // no more terms available

            double termValue = row.get(col) == null ? 0.0 : ((Number) row.get(col)).doubleValue();

            int daysInTerm = calculateDaysInTerm(tableUsed, termStart);

            double dailyVal = termValue / daysInTerm;

            for (int i = 0; i < daysInTerm && remainingDays > 0; i++) {
                dailySales.put(runningDate.toString(), dailyVal);

                runningDate = runningDate.plusDays(1);
                termStart = termStart.plusDays(1);

                remainingDays--;
            }

            currentTerm++;
        }

        // 5. Total Sum
        double totalSales = dailySales.values().stream().mapToDouble(Double::doubleValue).sum();

        // 6. Response Map
        Map<String, Object> response = new LinkedHashMap<>();
        response.put("tableUsed", tableUsed);
        response.put("startDate", startDate);
        response.put("duration", duration);
        response.put("dailySales", dailySales);
        response.put("totalSales", totalSales);

        return response;
    }


    // -------------------------------------------------------
    // CALENDAR ACCURATE TERM LENGTH CALCULATION
    // -------------------------------------------------------
    private int calculateDaysInTerm(String tableUsed, LocalDate termStart) {

        switch (tableUsed) {

            case "weekly":
                return 7;

            case "monthly": {
                YearMonth ym = YearMonth.of(termStart.getYear(), termStart.getMonth());
                return ym.lengthOfMonth();
            }

            case "quarterly": {
                LocalDate end = termStart.plusMonths(3).minusDays(1);
                return (int) ChronoUnit.DAYS.between(termStart, end) + 1;
            }

            default:
                throw new RuntimeException("Unknown table type: " + tableUsed);
        }
    }
}
